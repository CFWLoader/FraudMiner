\documentclass{article}

\usepackage{url}
%\usepackage{amsmath}
%\usepackage{amssymb}

%\DeclareMathOperator*{\argmin}{argmin}
%\DeclareMathOperator*{\argmax}{argmax}

\title{Overview of Parallel Graph Algorithms}
\date{2017-09-19}
\author{Evan Huang \\ cfwloader@gmail.com}

\begin{document}

	%\maketitle

	%\newpage

	\tableofcontents

	\pagenumbering{arabic}

	\newpage

	\section{Using Search Engine to discover}
	\subsection{Github}
	I search key words like \emph{distributed}, \emph{parallel} or \emph{giraph} to find the current progress for any papers, implemented codes.
	\subsubsection{Giraph}
	Firstly I found this project \emph{Giraph Classifier}\cite{giraph_classifier}. It's about label propagation.
	\newline
	There is a upper layer application\cite{dis_graph_ana} based on Giraph and GraphX, which implemented High Betweenness Set Extraction, Weakly Connected Components, Page Rank, Leaf Compression, and Louvain Modularity on them.

	\section{Brief of Parallel Graph Algorithms}
	Classic algorithms like \emph{Page Rank}, \emph{Single Source Shortest Path}, \emph{Randown Walks}, \emph{Triangle Count}, \emph{Connected Components}, \emph{etc.} are implemented as framework built-in demos. There is no need to talk about these algorithms.
	\begin{table}[!bhp]
	\begin{tabular}{|c|c|c|c|c|}
	\hline
	Algorithm					& 	Parallel 	& 	Published	& 	Open Souces	&	Platform(s)	\\
	\hline
	LPA							&	Yes			&	Yes			& 	Yes			&	GPU			\\
	\hline
	Louvain						&	Yes			&	Yes			&	Yes			&	GraphX		\\
	\hline
	K-Core Decomposition		& 	Yes			&	Yes			&	Yes			&	Giraph		\\
	\hline
	K-Means						&	Yes			&	Yes			&	Yes			&	Giraph 		\\
	\hline
	Influence Maximization		&	Yes			&	Yes			&	Yes			&	GPU,GraphX	\\
	\hline
	Stochastic Gradient Descend	&	Yes			&	Yes			&	Yes			&	Giraph 		\\
	\hline
	Graph Isomorphism			&	Yes			&	Yes			&	Yes			& 	CUDA		\\
	\hline
	Graph Coloring				&	Yes			&	Yes			& 	Yes			&	Giraph 		\\
	\hline
	Community Structure Dectection	& 	Yes		&	Yes			&	Yes			&	Giraph 		\\
	\hline
	Restricted Boltzmann Machine	& 	Yes		&	Unknown		&	Yes			&	Giraph 		\\
	\hline
	Non-negative Matrix Factorization	& 	Yes	&	Yes			&	Yes			&	GraphX		\\
	\hline
	Closeness Centrality 		&	Yes			&	Yes			& 	Yes			&	Multi-CPU	\\
	\hline
	k-Influential Community Search 	&	No 		&	No 			& 	No 			& 	None 		\\
	\hline
	Influence Maximization 		&	Yes			&	Yes			&	Yes			&	Unknown		\\
	\hline
	pSCAN(Chang)				&	Unknown		&	No 			&	No 			& 	None 		\\
	\hline
	PSCAN(Zhao)					& 	Yes			&	Yes			&	Unknown		&	MapReduce	\\
	\hline
	gSpan						&	Yes			& 	Yes			& 	Yes			& 	Java,CUDA,FPGA \\
	\hline
	DBScan						&	Yes			& 	Yes			& 	Yes			& 	MapReduce, FPGA \\
	\hline

	\hline

	\end{tabular}
	\caption{Brief of Parallel Graph Algorithms}
	\end{table}

	\section{Inspirations}
	\subsection{Community Detection}
	Lyu\cite{lyu2016scalable} states that select some best features from the graph information and then use these to eventually enlarge the subgraph to supergraph. 
	\newline
	Also, this algorithm needs to control the size of subgraphs(this maybe the disadvantage).
	\newline
	This idea inspired me of a new idea to process community detection cause the framework of this idea is like to Decision Tree. Can the algorithm use edge information to measure the score of features? And then use the feature to enlarge the graph to partitions(Communities).

	\begin{appendix}
		\section{References}
		\bibliography{opga_refs}
		\bibliographystyle{ieeetr}
	\end{appendix}

\end{document}